#!/usr/bin/python
# -*- coding: utf-8 -*-
### BEGIN LICENSE
# This file is in the public domain
### END LICENSE

import sys
import os
import gtk
import pango
import webkit
import couchdb
import desktopcouch
import webbrowser
from desktopcouch.records.server import CouchDatabase
from Cheetah.Template import Template

from twisted.internet import gtk2reactor
gtk2reactor.install()

from twisted.internet import reactor, defer
from twisted.web import client

webkit.WEB_NAVIGATION_REASON_OTHER = 5

webkit.LOAD_COMMITTED = 1
webkit.LOAD_FINISHED = 2
webkit.LOAD_FIRST_VISUALLY_NON_EMPTY_LAYOUT = 3

# Check if we are working in the source tree or from the installed 
# package and mangle the python path accordingly
if os.path.dirname(sys.argv[0]) != ".":
    if sys.argv[0][0] == "/":
        fullPath = os.path.dirname(sys.argv[0])
    else:
        fullPath = os.getcwd() + "/" + os.path.dirname(sys.argv[0])
else:
    fullPath = os.getcwd()
sys.path.insert(0, os.path.dirname(fullPath))

from feedie import AboutFeedieDialog, PreferencesFeedieDialog
from feedie.SourcesView import SourcesView
from feedie.posts_tree_model import PostsTreeModel
from feedie import models
from feedie.feedieconfig import getdatapath
from feedie import images
from feedie import incoming
from feedie import util
from feedie import http
from feedie import database

MAX_FEED_DOC_SIZE = 1000000

from feedie import design_doc

sources = None

post_template = Template(file=getdatapath() + '/templates/post.html')
source_template = Template(file=getdatapath() + '/templates/source.html')

class FeedieWindow(gtk.Window):
    __gtype_name__ = "FeedieWindow"

    def __init__(self):
        """__init__ - This function is typically not called directly.
        Creation a FeedieWindow requires redeading the associated ui
        file and parsing the ui definition extrenally,
        and then calling FeedieWindow.finish_initializing().

        Use the convenience function NewFeedieWindow to create
        FeedieWindow object.

        """

        couchdb = CouchDatabase('feedie', create=True).db
        oauth_tokens = desktopcouch.local_files.get_oauth_tokens()
        self.db = database.AsyncCouch(couchdb, oauth_tokens)

        design_doc.add_views(self.db)

    @defer.inlineCallbacks
    def finish_initializing_async_part(self):
      yield sources.load()


    def finish_initializing(self, builder):
        global sources
        """finish_initalizing should be called after parsing the ui definition
        and creating a FeedieWindow object with it in order to finish
        initializing the start of the new FeedieWindow instance.

        """
        #get a reference to the builder and set up the signals
        self.builder = builder
        self.builder.connect_signals(self)

        #uncomment the following code to read in preferences at start up
        #dlg = PreferencesFeedieDialog.NewPreferencesFeedieDialog()
        #self.preferences = dlg.get_preferences()

        #code for other initialization actions should be added here

        # now add other widgets that glade doesn't know about

        sources = models.Sources(self.db)
        self.sources_view = SourcesView(sources)
        unreadnews = models.UnreadNewsSource(self.db)
        sources.add_builtin(unreadnews)
        self.sources_view.show()

        self.builder.get_object('sources-scrolledwindow').add_with_viewport(self.sources_view)
        vp = self.builder.get_object('sources-scrolledwindow').get_child()
        vp.set_shadow_type(gtk.SHADOW_NONE)

        def poppop(webview, menu):
          def blah_blah(item):
            pass

          for item in menu:
            menu.remove(item)

          item = gtk.MenuItem('_Blah Blah')
          item.show()
          item.connect('activate', blah_blah)
          menu.append(item)

        def nav_policy(view, frame, request, nav_action, decision):
          reason = nav_action.get_reason()
          if reason == webkit.WEB_NAVIGATION_REASON_OTHER:
            decision.use()
          else:
            webbrowser.open_new(request.get_uri())
            decision.ignore()
          return True

        def request_starting(view, frame, resource, request, response):
          uri = request.get_uri()
          if uri.startswith('res:'):
            pass

        posts_status = self.builder.get_object('posts-status')
        posts_status.set_text('')
        def web_hovering_over_link(view, title, uri):
          message = uri if uri else ''
          posts_status.set_text(message)

        self.web = webkit.WebView()
        self.web.set_maintains_back_forward_list(False)
        self.web.set_custom_encoding('UTF-8')
        self.web.connect('populate-popup', poppop)
        self.web.connect('navigation-policy-decision-requested', nav_policy)
        self.web.connect('resource-request-starting', request_starting)
        self.web.connect('hovering-over-link', web_hovering_over_link)
        websettings = self.web.get_settings()
        websettings.set_property('user-stylesheet-uri',
            'file://' + getdatapath() + '/css/Default.css')
        self.web.show()

        self.builder.get_object('scrolledwindow1').add(self.web)

        self.current_post_ids = None

        post_id_colnum = PostsTreeModel.colnum('post_id')
        feed_id_colnum = PostsTreeModel.colnum('feed_id')

        to_cancel = []
        @defer.inlineCallbacks
        def update_web_view():
          def loaded(view, progress, post):
            okay_to_mark_read = [True]
            def set_read_at():
              if okay_to_mark_read[0]:
                treeviewsel = treeview.get_selection()
                if treeviewsel.count_selected_rows() == 1:
                  model, (path,) = treeviewsel.get_selected_rows()
                  iter = model.get_iter(path)
                  post_id = model.get_value(iter, post_id_colnum)
                  if post._id == post_id:
                    post.set_read_at()

            def cancel():
              okay_to_mark_read[0] = False

            frame = self.web.get_main_frame()
            status = frame.get_property('load-status')
            if status in (webkit.LOAD_FIRST_VISUALLY_NON_EMPTY_LAYOUT,
                          webkit.LOAD_FINISHED):
              self.web.disconnect(handler_id)
              reactor.callLater(0.20, set_read_at)
              to_cancel.append(cancel)

          if self.current_post_ids:
            feed_id, post_id = self.current_post_ids
            feed = sources.get_feed(feed_id)
            post = yield feed.get_post(post_id)
            yield post.load_doc()
            post_template.post = post
            post_template.display_feed = (feed_id != self.sources_view.selected_id)
            html = str(post_template)
            base = post.base()
            while to_cancel:
              to_cancel.pop()()
            handler_id = self.web.connect('load-progress-changed', loaded, post)
          else:
            html, base = '', ''

          self.web.load_html_string(html, base)

        def treeview_selection_changed(treeviewsel):
          if treeviewsel.count_selected_rows() == 1:
            model, (path,) = treeviewsel.get_selected_rows()
            iter = model.get_iter(path)
            new_post_ids = (model.get_value(iter, feed_id_colnum),
                            model.get_value(iter, post_id_colnum))
          else:
            new_post_ids = None

          while to_cancel:
            to_cancel.pop()()

          if new_post_ids != self.current_post_ids:
            self.current_post_ids = new_post_ids
            update_web_view()

        treeview = self.builder.get_object('posts-treeview')
        treeview.set_property('rules-hint', True)
        treeviewsel = treeview.get_selection()
        treeviewsel.set_mode(gtk.SELECTION_MULTIPLE)
        treeviewsel.connect('changed', treeview_selection_changed)
        update_web_view()

        treeview_heading_widgets = []

        sources_status = self.builder.get_object('sources-status')

        def style_set(widget, previous_style):
          def modify_all(widget, fd):
            widget.modify_font(fd)
            if isinstance(widget, gtk.Container):
              for child in widget.get_children():
                modify_all(child, fd)

          fd = widget.get_style().font_desc.copy()
          if fd.get_size() > (9 * pango.SCALE):
            fd.set_size(int(fd.get_size() / 1.2))
          self.sources_view.modify_font(fd)
          treeview.modify_font(fd)
          sources_status.modify_font(fd)
          posts_status.modify_font(fd)
          for col in treeview.get_columns():
            w = col.get_widget()
            if w: w.modify_font(fd)

        self.connect('style-set', style_set)

        treeview.insert_column_with_attributes(0, 'Starred',
            gtk.CellRendererPixbuf(),
            pixbuf=PostsTreeModel.colnum('star'))
        treeview.get_column(0).set_sizing(gtk.TREE_VIEW_COLUMN_FIXED)
        treeview.get_column(0).set_fixed_width(24)
        treeview.get_column(0).set_min_width(24)
        treeview.get_column(0).set_max_width(24)
        star_heading = images.make_widget('blank')
        star_heading.show()
        treeview_heading_widgets.append(star_heading)
        treeview.get_column(0).set_widget(star_heading)

        treeview.insert_column_with_attributes(1, 'Read',
            gtk.CellRendererPixbuf(),
            pixbuf=PostsTreeModel.colnum('read'))
        treeview.get_column(1).set_sizing(gtk.TREE_VIEW_COLUMN_FIXED)
        treeview.get_column(1).set_fixed_width(24)
        treeview.get_column(1).set_min_width(24)
        treeview.get_column(1).set_max_width(24)
        read_heading = images.make_widget('blank')
        read_heading.show()
        treeview_heading_widgets.append(read_heading)
        treeview.get_column(1).set_widget(read_heading)

        title_cell_renderer = gtk.CellRendererText()
        title_cell_renderer.set_property('ellipsize', pango.ELLIPSIZE_END)
        treeview.insert_column_with_attributes(2, 'Title',
            title_cell_renderer,
            text=PostsTreeModel.colnum('title'),
            weight=PostsTreeModel.colnum('weight'))
        treeview.get_column(2).set_sort_column_id(PostsTreeModel.colnum('title'))
        treeview.get_column(2).set_expand(True)
        treeview_title_heading = gtk.Label('Title')
        treeview_title_heading.show()
        treeview_heading_widgets.append(treeview_title_heading)
        treeview.get_column(2).set_widget(treeview_title_heading)

        updated_cell_renderer = gtk.CellRendererText()
        updated_cell_renderer.set_property('ellipsize', pango.ELLIPSIZE_END)
        treeview.insert_column_with_attributes(3, 'Date',
            updated_cell_renderer,
            text=PostsTreeModel.colnum('pretty_date'))
        treeview.get_column(3).set_sort_column_id(PostsTreeModel.colnum('age'))
        treeview.get_column(3).set_sizing(gtk.TREE_VIEW_COLUMN_FIXED)
        treeview.get_column(3).set_fixed_width(100)
        treeview.get_column(3).set_min_width(100)
        treeview.get_column(3).set_max_width(100)
        treeview_date_heading = gtk.Label('Date')
        treeview_date_heading.show()
        treeview_heading_widgets.append(treeview_date_heading)
        treeview.get_column(3).set_widget(treeview_date_heading)

        main_area = self.builder.get_object('main-area')
        status_paned = self.builder.get_object('status-paned')

        def update_unread_counts(*args):
          message = '%d unread' % (unreadnews.unread,)
          sources_status.set_text(message)
          self.set_title('Feedie (%s)' % (message,))

        unreadnews.connect('summary-changed', update_unread_counts)
        update_unread_counts()

        def sources_pane_resized(sv, rect):
          new_pos = main_area.get_position()
          if status_paned.get_position() != new_pos:
            status_paned.set_position(new_pos)

        def status_paned_resized(sp, rect):
          new_pos = status_paned.get_position()
          if main_area.get_position() != new_pos:
            main_area.set_position(new_pos)

        self.sources_view.connect('size-allocate', sources_pane_resized)
        sources_status.connect('size-allocate', status_paned_resized)
        self.builder.get_object('vpaned1').set_position(200)
        main_area.set_position(225)
        blue = gtk.gdk.color_parse('#7db6ff')
        self.builder.get_object('subscribe-box').modify_bg(gtk.STATE_NORMAL, blue)

        selected_source_to_remove = []
        self.sources_view.connect('selection-changed', self.select_feed,
            selected_source_to_remove)
        self.select_feed(self.sources_view, None, selected_source_to_remove)

        d = self.finish_initializing_async_part()

    def select_feed(self, widget, selected_id, to_remove):
      source = widget.selected

      removable = bool(source and sources.can_remove(source))
      self.builder.get_object('action-remove-feed').set_sensitive(removable)

      refreshable = bool(source and source.can_refresh)
      self.builder.get_object('action-refresh').set_sensitive(refreshable)

      if not source:
        treeview = self.builder.get_object('posts-treeview')
        treeview.set_model(None)
        treeview.get_column(2).get_widget().set_text('')
        self.builder.get_object('scrolledwindow2').hide()
        self.web.load_html_string('Welcome', 'file:///')
        return

      if not source.error:
        def show(x, source):
          def update_title(model, path, iter):
            title = u'%s \u2013 %d posts' % (source.title, len(model))
            treeview.get_column(2).get_widget().set_text(title)

          model = gtk.TreeModelSort(raw_model)
          model.set_sort_column_id(PostsTreeModel.colnum('age'),
              gtk.SORT_ASCENDING)
          model.set_default_sort_func(None)

          treeview = self.builder.get_object('posts-treeview')
          treeview.set_model(model)
          model.connect('row-inserted', update_title)
          model.connect('row-deleted', update_title)
          update_title(model, None, None)
          self.builder.get_object('scrolledwindow2').show()

        raw_model = PostsTreeModel(source)
        for disconnecter in to_remove:
          disconnecter()
        to_remove[:] = []
        to_remove.append(source.connect('post-added', raw_model.post_added))
        to_remove.append(source.connect('post-removed', raw_model.post_removed))
        d = raw_model.load()
        d.addCallback(show, source)
      else:
        treeview = self.builder.get_object('posts-treeview')
        treeview.set_model(None)
        treeview.get_column(2).get_widget().set_text('')
        self.builder.get_object('scrolledwindow2').hide()

      source_template.source = source
      html = str(source_template)
      self.web.load_html_string(html, 'file:///')


    def about(self, widget, data=None):
        """about - display the about box for feedie """
        about = AboutFeedieDialog.NewAboutFeedieDialog()
        response = about.run()
        about.destroy()

    def preferences(self, widget, data=None):
        """preferences - display the preferences window for feedie """
        prefs = PreferencesFeedieDialog.NewPreferencesFeedieDialog()
        response = prefs.run()
        if response == gtk.RESPONSE_OK:
            #make any updates based on changed preferences here
            pass
        prefs.destroy()

    def quit(self, widget, data=None):
        """quit - signal handler for closing the FeedieWindow"""
        self.destroy()

    def on_destroy(self, widget, data=None):
        """on_destroy - called when the FeedieWindow is close. """
        #clean up code for saving application state should be added here

        #gtk.main_quit()
        reactor.stop()

    def show_subscribe(self, widget, data=None):
        self.builder.get_object('subscribe-box').show()
        self.builder.get_object('subscribe-entry').grab_focus()

    def cancel_subscribe(self, widget, data=None):
        self.hide_subscribe_box()

    def start_subscribe(self):
        def success(feed):
          self.sources_view.select(feed.id)
          self.sources_view.flash(feed.id)

        # This should never happen. If it does, just dump out a stack trace.
        # It's best for debugging, and we can't help the user anyway.
        def failure(reason):
          raise reason

        uri = self.hide_subscribe_box()

        d = sources.subscribe(uri)
        d.addCallback(success)
        d.addErrback(failure)

    def subscribe_cb(self, widget, data=None):
        self.start_subscribe()

    def hide_subscribe_box(self):
        self.builder.get_object('subscribe-box').hide()
        text = self.builder.get_object('subscribe-entry').get_text()
        self.builder.get_object('subscribe-entry').set_text('')
        return text

    def subscribe_entry_keypress(self, widget, data=None):
        key = gtk.gdk.keyval_name(data.keyval)

        if key == 'Return':
          self.start_subscribe()
          return

        if key == 'Escape':
          self.hide_subscribe_box()
          return

    def remove_feed(self, widget, data=None):
      sel = self.sources_view.selected
      if sel:
        sel.delete()

    def refresh(self, widget, data=None):
      def success(x):
        self.sources_view.flash(sel.id)
      sel = self.sources_view.selected
      if sel:
        d = sel.refresh(force=True)
        d.addCallback(success)

def NewFeedieWindow():
    """NewFeedieWindow - returns a fully instantiated
    FeedieWindow object. Use this function rather than
    creating a FeedieWindow directly.
    """

    #look for the ui file that describes the ui
    ui_filename = os.path.join(getdatapath(), 'ui', 'FeedieWindow.ui')
    if not os.path.exists(ui_filename):
        ui_filename = None

    builder = gtk.Builder()
    builder.add_from_file(ui_filename)
    window = builder.get_object("feedie_window")
    window.set_icon_from_file(getdatapath() + '/media/logo.png')
    window.finish_initializing(builder)
    return window

if __name__ == "__main__":
    #support for command line options
    import logging, optparse
    parser = optparse.OptionParser(version="%prog %ver")
    parser.add_option("-v", "--verbose", action="store_true", dest="verbose", help="Show debug messages")
    (options, args) = parser.parse_args()

    #set the logging level to show debug messages
    if options.verbose:
        logging.basicConfig(level=logging.DEBUG)
        logging.debug('logging enabled')

    gtk.rc_parse_string('''
style "feedie-scrolledwindow"
{
  GtkScrolledWindow::scrollbar-spacing = 0
}
class "GtkWidget" style "feedie-scrolledwindow"
    ''')

    #run the application
    gtk.gdk.threads_init()
    window = NewFeedieWindow()
    window.set_default_size(800, 800)
    window.show()
    #gtk.main()
    reactor.run()

